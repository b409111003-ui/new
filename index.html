<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>社區散步友善地圖（OSRM 無 API Key 版）</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #map {
      height: 100vh;
      width: 100%;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 10000;
      font-size: 14px;
      pointer-events: auto;
    }
    .controls label { display: block; margin: 4px 0; }
    .controls input[type="number"] { width: 80px; }
    .controls button {
      margin-top: 6px; padding: 4px 8px; border-radius: 6px; border: none;
      background: #4CAF50; color: white; cursor: pointer;
    }
    .warning-box {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: rgba(255,240,220,0.95);
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.12);
      z-index: 10000;
      font-size: 14px;
      display: none;
    }
    .warning-box.show { display: block; }
  </style>
</head>
<body>
  <div class="controls">
    <label><input type="checkbox" value="water"> 飲水機</label>
    <label><input type="checkbox" value="convenience"> 便利商店</label>
    <label><input type="checkbox" value="market"> 市場</label>
    <label><input type="checkbox" value="park"> 公園</label>
    <label>搜尋半徑 (公尺)：<input type="number" id="radiusInput" value="1000" min="100" step="100"></label>
    <button id="searchBtn">搜尋附近</button>
  </div>

  <div id="map"></div>
  <div id="warning" class="warning-box"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // ---------- 基本地圖與定位 ----------
    const map = L.map('map', { zoomControl: false }).setView([25.0330, 121.5654], 15);
    L.control.zoom({ position: "bottomright" }).addTo(map);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap'
    }).addTo(map);

    let userMarker;
    navigator.geolocation.watchPosition(pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      if (!userMarker) {
        userMarker = L.marker([lat, lon]).addTo(map).bindPopup("你在這裡");
        map.setView([lat, lon], 16);
      } else {
        userMarker.setLatLng([lat, lon]);
      }
    }, err => {
      console.warn("定位失敗或被拒絕：", err);
    }, { enableHighAccuracy: true });

    // ---------- Icons / categories ----------
    const icons = {
      water: L.icon({ iconUrl: "https://cdn-icons-png.flaticon.com/512/2910/2910768.png", iconSize: [30,30] }),
      convenience: L.icon({ iconUrl: "https://openmoji.org/data/color/svg/1F3EA.svg", iconSize: [30,30] }),
      market: L.icon({ iconUrl: "https://cdn-icons-png.flaticon.com/512/415/415682.png", iconSize: [30,30] }),
      park: L.icon({ iconUrl: "https://cdn-icons-png.flaticon.com/512/427/427735.png", iconSize: [30,30] })
    };

    const categories = {
      water: 'node["amenity"="drinking_water"](around:RADIUS,LAT,LON);',
      convenience: 'node["shop"="convenience"](around:RADIUS,LAT,LON);',
      market: 'node["amenity"="marketplace"](around:RADIUS,LAT,LON);',
      park: 'way["leisure"="park"](around:RADIUS,LAT,LON);'
    };

    function buildOverpassQuery(lat, lon, radius, selections) {
      if (!selections || selections.length === 0) return null;
      let body = '[out:json][timeout:25];(';
      for (const sel of selections) {
        let fragment = categories[sel];
        fragment = fragment.replace(/RADIUS/g, radius).replace(/LAT/g, lat).replace(/LON/g, lon);
        body += "\n" + fragment;
      }
      body += '\n);out center;';
      return body;
    }

    // ---------- 搜尋與顯示 markers ----------
    let searchMarkers = [];
    let routeLayer = null;
    let stepsLayer = null; // 標示 steps 的 layer

    document.getElementById("searchBtn").addEventListener("click", () => {
      if (!userMarker) { alert("尚未取得定位"); return; }
      const pos = userMarker.getLatLng();
      const checked = Array.from(document.querySelectorAll("input[type=checkbox]:checked")).map(c => c.value);
      const radius = parseInt(document.getElementById("radiusInput").value) || 1000;
      const query = buildOverpassQuery(pos.lat, pos.lng, radius, checked);
      if (!query) { alert("請先選擇要搜尋的類別"); return; }

      // 清除舊結果
      searchMarkers.forEach(m => map.removeLayer(m));
      searchMarkers = [];
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      if (stepsLayer) { map.removeLayer(stepsLayer); stepsLayer = null; document.getElementById('warning').classList.remove('show'); }

      fetch("https://overpass-api.de/api/interpreter", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: "data=" + encodeURIComponent(query)
      })
      .then(r => {
        if (!r.ok) return r.text().then(t => { throw new Error("Overpass HTTP " + r.status + ": " + t); });
        return r.json();
      })
      .then(data => {
        data.elements.forEach(el => {
          const lat = el.lat || el.center?.lat;
          const lon = el.lon || el.center?.lon;
          if (!lat || !lon) return;

          let matchedType = null;
          if (el.tags) {
            if (el.tags.amenity === "drinking_water") matchedType = "water";
            else if (el.tags.shop === "convenience") matchedType = "convenience";
            else if (el.tags.amenity === "marketplace") matchedType = "market";
            else if (el.tags.leisure === "park") matchedType = "park";
          }

          const marker = L.marker([lat, lon], { icon: matchedType ? icons[matchedType] : undefined }).addTo(map);
          marker.bindPopup(`
            <b>${el.tags?.name || matchedType || "地點"}</b><br>
            <a href="https://www.google.com/maps/dir/?api=1&destination=${lat},${lon}" target="_blank">導航</a><br>
            <button onclick="planRoute(${lat},${lon})">規劃友善步行路線（模擬無障礙）</button>
          `);
          searchMarkers.push(marker);
        });
      })
      .catch(err => {
        console.error(err);
        alert("查詢失敗：" + (err.message || err));
      });
    });

    // ---------- OSRM 路徑、Overpass steps 檢查與顯示 ----------
    // helper: 計算 bbox (south, west, north, east) from coords
    function bboxFromCoords(coords, padMeters = 20) {
      let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
      coords.forEach(c => {
        const lat = c[1], lon = c[0];
        if (lat < minLat) minLat = lat;
        if (lat > maxLat) maxLat = lat;
        if (lon < minLon) minLon = lon;
        if (lon > maxLon) maxLon = lon;
      });
      // pad in degrees (approx). 1 deg lat ~111km. For lon, use cos(avgLat)
      const avgLat = (minLat + maxLat) / 2;
      const padDegLat = padMeters / 111000;
      const padDegLon = padMeters / (111000 * Math.cos(avgLat * Math.PI/180));
      return [minLat - padDegLat, minLon - padDegLon, maxLat + padDegLat, maxLon + padDegLon];
    }

    // helper: show warning box
    function showWarning(text) {
      const el = document.getElementById('warning');
      el.innerText = text;
      el.classList.add('show');
    }

    // planRoute: 使用 OSRM public server (no API key)
    async function planRoute(destLat, destLon) {
      if (!userMarker) { alert("尚未取得定位"); return; }
      const start = userMarker.getLatLng();

      // 移除先前路線與 steps 標記
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      if (stepsLayer) { map.removeLayer(stepsLayer); stepsLayer = null; document.getElementById('warning').classList.remove('show'); }

      // OSRM route request (foot profile)
      const osrmUrl = `https://router.project-osrm.org/route/v1/foot/${start.lng},${start.lat};${destLon},${destLat}?overview=full&geometries=geojson&steps=true`;
      try {
        const r = await fetch(osrmUrl);
        if (!r.ok) {
          const text = await r.text();
          throw new Error("OSRM HTTP " + r.status + ": " + text);
        }
        const data = await r.json();
        if (!data.routes || data.routes.length === 0) throw new Error("OSRM 未回傳路線");

        const geom = data.routes[0].geometry; // geojson LineString
        const coords = geom.coordinates; // [ [lon,lat], ... ]

        // 把路線畫到地圖上
        const latlngs = coords.map(c => [c[1], c[0]]);
        routeLayer = L.polyline(latlngs, { color: "blue", weight: 5 }).addTo(map);
        map.fitBounds(routeLayer.getBounds(), { padding: [40,40] });

        // 用 Overpass 查詢路線 bounding box 內是否有 highway=steps
        const bbox = bboxFromCoords(coords, 25); // 25 公尺外延
        const south = bbox[0], west = bbox[1], north = bbox[2], east = bbox[3];
        const overpassStepsQuery = `[out:json][timeout:25];
          (
            way["highway"="steps"](${south},${west},${north},${east});
            node["highway"="steps"](${south},${west},${north},${east});
          );
          out center;`;

        const r2 = await fetch("https://overpass-api.de/api/interpreter", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: "data=" + encodeURIComponent(overpassStepsQuery)
        });
        if (!r2.ok) {
          const t = await r2.text();
          console.warn("Overpass steps query failed:", r2.status, t);
        } else {
          const stepsData = await r2.json();
          if (stepsData.elements && stepsData.elements.length > 0) {
            // 把 steps 顯示在地圖上（以紅色小圓點或 polyline）
            const stepMarkers = [];
            const stepWays = [];
            stepsData.elements.forEach(el => {
              if (el.type === "node") {
                stepMarkers.push([el.lat, el.lon]);
              } else if (el.type === "way") {
                // way 可能有 .center or .geometry (Overpass returns geometry sometimes)
                if (el.center) stepMarkers.push([el.center.lat, el.center.lon]);
                if (el.geometry) stepWays.push(el.geometry.map(g => [g.lat, g.lon]));
              }
            });

            const group = L.layerGroup();
            stepMarkers.forEach(p => {
              L.circleMarker(p, { radius: 6, color: "red", fillColor: "#f03", fillOpacity: 0.8 })
                .bindPopup("偵測到階梯（node）")
                .addTo(group);
            });
            stepWays.forEach(pts => {
              L.polyline(pts, { color: "red", weight: 4, dashArray: "4 6" })
                .bindPopup("偵測到階梯（way）")
                .addTo(group);
            });
            stepsLayer = group.addTo(map);

            // 顯示警示
            showWarning("注意：此路線附近偵測到 steps（階梯），可能不友善。地圖上以紅色標示。");
          } else {
            // 沒有偵測到 steps
            // 隱藏警示（已在前面清除）
          }
        }
      } catch (err) {
        console.error(err);
        alert("路線規劃失敗（使用 OSRM）：" + (err.message || err));
      }
    }

    // 讓 popup button 可以呼叫
    window.planRoute = planRoute;

    // ---------- 小提示：可加入一次規劃所有搜尋結果的功能（若需要可再加） ----------
  </script>
</body>
</html>
